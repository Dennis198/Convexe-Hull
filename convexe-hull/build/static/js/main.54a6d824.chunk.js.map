{"version":3,"sources":["ConvexeHull/Help/drawMethods.js","ConvexeHull/Plane/Point/point.js","ConvexeHull/Help/calculations.js","ConvexeHull/Algorithms/gift-wrapping-algorithm.js","ConvexeHull/Algorithms/naive.js","ConvexeHull/Algorithms/graham-scan.js","ConvexeHull/Plane/plane.js","ConvexeHull/convexehull.js","App.js","reportWebVitals.js","index.js"],"names":["reset","canvas","document","getElementById","context","getContext","beginPath","fillStyle","fillRect","width","height","stroke","drawPoint","x","y","size","color","arc","Math","PI","fill","drawLine","start","end","strokeStyle","lineWidth","moveTo","lineTo","drawPolygonLines","hull","endToStart","i","length","Point","this","crossProductZ","vectorOne","vectorTwo","subtract","pointA","pointB","orientationTest","firstPoint","secondPoint","thirdPoint","initAngleArray","startPoint","points","sort","a","b","supportPoint","firstAngle","getAngle","secondAngle","console","log","firstDistance","getDistance","secondDistance","compareator","vertex","firstVector","secondVector","getDotProduct","angle","acos","getLength","vector","sqrt","GiftWrappingAlgorithm","sucess","leftMost","index","nextIndex","nextVertex","currentVertex","push","calculateNextStep","drawFinish","intervallID","setInterval","drawCurrentState","checking","stop","draw","id","clearInterval","NaiveAlgorithm","success","hullLines","checked","startIdx","endIdx","j","find","obj","isLineOnHull","k","i_ONHOLD","j_ONHOLD","p","GrahamScan","n","pop","pt_1","pt_2","finished","Plane","algorithm","isFinished","instantCompute","ConvexeHull","props","state","plane","isRunning","algoMode","setState","naive","giftWrapping","grahamScan","isAlgorithmFinished","setTimeout","interval_id","window","random","addPoint","e","pos","getMousePos","evt","rect","getBoundingClientRect","clientX","left","clientY","top","parseInt","target","value","resetHull","className","onChange","val","switchAlgoMode","Button","disabled","variant","onClick","fastCompute","animation","stopAll","addRandomPoints","React","Component","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.54a6d824.chunk.js","sourcesContent":["/**\r\n * This File contains all Methods which are needed for drawing on the Canvas\r\n */\r\n\r\n //Resets the Canvas to the inital state\r\nexport function reset(){\r\n    var canvas = document.getElementById(\"2d-plane\");\r\n    var context = canvas.getContext(\"2d\");\r\n    context.beginPath();\r\n    context.fillStyle = \"#ADD8E6\";\r\n    context.fillRect(0,0,canvas.width,canvas.height);\r\n    context.stroke(); \r\n}\r\n\r\n//Draws a Point at location x,y with the size size and color color\r\nexport function drawPoint(x, y, size=4, color=\"black\"){\r\n    var canvas = document.getElementById(\"2d-plane\");\r\n    var context = canvas.getContext(\"2d\");\r\n    context.fillStyle = color;//`#DC143C`;//Red\r\n    context.beginPath();\r\n    context.arc(x, y, size, 0, 2*Math.PI);\r\n    context.fill();\r\n}\r\n\r\n//Draws a Line from start to end with color\r\nexport function drawLine(start, end, color=\"black\"){\r\n    var canvas = document.getElementById(\"2d-plane\");\r\n    var context = canvas.getContext(\"2d\");\r\n    context.strokeStyle=color;\r\n    context.lineWidth=1;\r\n    context.beginPath();\r\n    context.moveTo(start.x, start.y);\r\n    context.lineTo(end.x, end.y);\r\n    context.stroke();\r\n}\r\n\r\n//Draws all Lines of the hull\r\nexport function  drawPolygonLines(hull, color=\"black\", endToStart=false){\r\n    var canvas = document.getElementById(\"2d-plane\");\r\n    var context = canvas.getContext(\"2d\");\r\n    context.strokeStyle=color;\r\n    context.lineWidth=1;\r\n    context.beginPath();\r\n    context.moveTo(hull[0].x,hull[0].y);\r\n    for(let i=1;i<hull.length;i++){\r\n        context.lineTo(hull[i].x,hull[i].y);\r\n        context.stroke();\r\n    }\r\n    if(endToStart){\r\n        context.lineTo(hull[0].x,hull[0].y);    \r\n    }\r\n    context.stroke();\r\n}\r\n\r\n\r\n//Draws the and fills the hull\r\nexport function drawPolygon(hull){\r\n    if(hull.length<2) return;\r\n    var canvas = document.getElementById(\"2d-plane\");\r\n    var context = canvas.getContext(\"2d\");\r\n    context.beginPath();\r\n    context.moveTo(hull[0].x,hull[0].y);\r\n    for(let i=1;i<hull.length;i++){\r\n        context.lineTo(hull[i].x,hull[i].y);\r\n    }\r\n    context.fillStyle=\"rgba(220, 20, 60,0.3)\";\r\n    context.fill();\r\n}","/**\r\n * This File Contains the Information about a Point\r\n */\r\nimport {drawPoint} from \"../../Help/drawMethods\";\r\nexport default class Point{\r\n\r\n    constructor(x,y){\r\n        this.x=x;\r\n        this.y=y;\r\n    }\r\n\r\n    //Draws it self\r\n    draw(size=4,color=\"black\"){\r\n        drawPoint(this.x,this.y,size,color);\r\n    }\r\n}","/**\r\n * This File contains different vector based operations, CrossProduct, determinante, ...\r\n */\r\nconst TOLERANCE=0.00;\r\n\r\n //Computes the Z Komponent of the Crossproduct of to vectors\r\nexport function crossProductZ(vectorOne,vectorTwo){\r\n    return vectorOne.x*vectorTwo.y - vectorOne.y*vectorTwo.x;\r\n}\r\n\r\n//Subtracts two Points\r\nexport function subtract(pointA,pointB){\r\n    return {x:pointA.x-pointB.x,y:pointA.y-pointB.y}\r\n}\r\n\r\n // Check if the third Point is on the right of the line between\r\n//  firstpoint to secondpoint.( det = determinant)\r\nexport function orientationTest(firstPoint, secondPoint, thirdPoint){\r\n    let det = firstPoint.x*secondPoint.y*1+\r\n                firstPoint.y*1*thirdPoint.x+\r\n                1*secondPoint.x*thirdPoint.y-\r\n                thirdPoint.x*secondPoint.y*1-\r\n                thirdPoint.y*1*firstPoint.x-\r\n                1*secondPoint.x*firstPoint.y;\r\n    return det<0;\r\n}\r\n\r\n// Sort the Array in increasing Order of the Angel they and the point startPoint make with the x-axis\r\nexport function initAngleArray(startPoint, points){\r\n    return points.sort((a,b) => compareator(startPoint, a, b));\r\n}\r\n\r\n//Help Function to Sort the Array depend on the Angle\r\nfunction compareator(startPoint, firstPoint, secondPoint){\r\n    const supportPoint = {\r\n        x: startPoint.x - 1,\r\n        y: startPoint.y,\r\n      };\r\n      const firstAngle = getAngle(startPoint, supportPoint, firstPoint);\r\n      const secondAngle = getAngle(startPoint, supportPoint, secondPoint);\r\n      if(firstAngle===0)console.log(\"Hier\");\r\n      if (firstAngle < secondAngle) {\r\n        return -1;\r\n      }\r\n      if (firstAngle > secondAngle) {\r\n        return 1;\r\n      }\r\n      const firstDistance = getDistance(startPoint, firstPoint);\r\n      const secondDistance = getDistance(startPoint, secondPoint);\r\n      if (firstDistance < secondDistance) {\r\n        return 1;\r\n      } \r\n      if (firstDistance > secondDistance) {\r\n        return -1;\r\n      }\r\n      return 0;\r\n}\r\n\r\n//Calculates the angle\r\nfunction getAngle(vertex, firstPoint, secondPoint){\r\n    const firstVector = {\r\n        x: firstPoint.x - vertex.x,\r\n        // Note that we negate y-coordinate since\r\n        // canvas flips axis\r\n        y: firstPoint.y - vertex.y,\r\n      };\r\n      const secondVector = {\r\n        x: secondPoint.x - vertex.x,\r\n        // Note that we negate y-coordinate since\r\n        // canvas flips axis\r\n        y: secondPoint.y - vertex.y,\r\n      };\r\n      // Check if the firstPoint or secondPoint is equal to the vertex\r\n      if (firstVector.x === 0 && firstVector.y === 0) return 0;\r\n      if (secondVector.x === 0 && secondVector.y === 0) return 0;\r\n      // Dot product is 0 precisely when vectors are perpendicular\r\n      if (getDotProduct(firstVector, secondVector) === 0) return 90;\r\n      const angle = Math.acos(\r\n        getDotProduct(firstVector, secondVector) / (getLength(firstVector) * getLength(secondVector)),\r\n      ) * 180 / Math.PI;\r\n      // Return 180 if almost collinear\r\n      if (180 - TOLERANCE <= angle && angle <= 180 + TOLERANCE) return 180;\r\n    \r\n      return angle;\r\n}\r\n\r\n//Calculates the Dot Product of two vectors\r\nfunction getDotProduct(firstVector,secondVector){\r\n    return firstVector.x * secondVector.x + firstVector.y * secondVector.y;\r\n   }\r\n\r\n//Calculates the length of a vector\r\nfunction getLength(vector){\r\n    return getDistance({x: 0, y:0}, vector);\r\n}\r\n\r\n//Calculates the Distance bwteen two points\r\nfunction getDistance(firstPoint, secondPoint){\r\n    return Math.sqrt((((firstPoint.x - secondPoint.x) ** 2) + ((firstPoint.y - secondPoint.y) ** 2)),);\r\n}\r\n\r\n","/**\r\n * This file computes the Gift Wrapping Algorithm to Compute the Convexe Hull\r\n */\r\nimport {drawPolygonLines, reset, drawLine} from \"../Help/drawMethods\";\r\nimport {subtract, crossProductZ} from \"../Help/calculations\";\r\n\r\nexport default class GiftWrappingAlgorithm{\r\n    constructor(points){\r\n        this.points=points.sort((a,b) => a.x-b.x);\r\n        this.sucess=false;\r\n        this.hull=[];\r\n        this.leftMost=this.points[0];\r\n        this.index=2;\r\n        this.nextIndex=-1;\r\n        this.nextVertex=this.points[1];\r\n        this.currentVertex=this.leftMost;\r\n        this.hull.push(this.leftMost);\r\n    }\r\n\r\n    //Computes the Algorithm \"fast\" (Only the finished Hull is displayed)\r\n    instantCompute(){\r\n        this.sucess=false\r\n        while(!this.sucess){\r\n            this.calculateNextStep();\r\n        }\r\n        this.drawFinish();\r\n    }\r\n\r\n    //Computes the Algorithm \"slow\" (Every Step is displayed)\r\n    start(){\r\n        let intervallID = setInterval(() => {\r\n            this.drawCurrentState();\r\n            this.calculateNextStep(intervallID);           \r\n        }, 100); \r\n    }\r\n\r\n    //Calculates the Nect Step of the Algorithm\r\n    calculateNextStep(intervallID=null){\r\n        let checking = this.points[this.index];\r\n        let a = subtract(this.nextVertex, this.currentVertex)\r\n        let b = subtract(checking, this.currentVertex);\r\n        if(crossProductZ(a,b)<0){\r\n            this.nextVertex=checking;\r\n            this.nextIndex=this.index;\r\n        }\r\n        this.index++;\r\n        if(this.index === this.points.length){\r\n            if(this.nextVertex === this.leftMost){\r\n                this.drawFinish();\r\n                this.stop(intervallID);\r\n\r\n            } else {\r\n                this.hull.push(this.nextVertex)\r\n                this.currentVertex=this.nextVertex;\r\n                this.index = 0;\r\n                this.nextVertex = this.leftMost;\r\n            }\r\n        } \r\n    }\r\n\r\n    //Draws the Current State (all Points, current points of the hull, and lines)\r\n    drawCurrentState(){\r\n        reset();\r\n        drawPolygonLines(this.hull, \"red\");       \r\n        drawLine(this.currentVertex, this.nextVertex, \"green\");\r\n        drawLine(this.currentVertex,this.points[this.index]);\r\n        for(let i=0;i<this.points.length;i++){\r\n            this.points[i].draw();\r\n        }\r\n\r\n        for(let i=0;i<this.hull.length;i++){\r\n            this.hull[i].draw(5,\"red\");\r\n        }\r\n    }\r\n\r\n    //Draws the Finished Convexe Hull\r\n    drawFinish(){\r\n        reset();\r\n        drawPolygonLines(this.hull, \"red\", true);\r\n        for(let i=0;i<this.points.length;i++){\r\n            this.points[i].draw();\r\n        }\r\n\r\n        for(let i=0;i<this.hull.length;i++){\r\n            this.hull[i].draw(5,\"red\");\r\n        }\r\n    }\r\n\r\n    //Stops the Interval and sets success to true (Convexe Hull is Found)\r\n    stop(id){\r\n        clearInterval(id);\r\n        this.sucess=true;\r\n    }\r\n}\r\n","/**\r\n * This File Computes a Naive Algorithm to find the Convexe Hull (O(n^3))\r\n */\r\nimport {reset, drawLine} from \"../Help/drawMethods\";\r\nimport {orientationTest} from \"../Help/calculations\";\r\n\r\nexport default class NaiveAlgorithm{\r\n    constructor(points){\r\n        this.points=points;\r\n        this.success=false;\r\n        this.hull=[];\r\n        this.hullLines=[];\r\n        this.checked = [{startIdx:-1, endIdx:-1}];//To Prevent check Point j->i if i->j is already on the convexe hull\r\n    }\r\n\r\n    //Computes the Algorithm \"fast\" (Only the finished Hull is displayed)\r\n    instantCompute(){\r\n        for(let i=0;i<this.points.length;i++){\r\n            for(let j=0;j<this.points.length;j++){\r\n                if(i===j) continue;\r\n                //To Prevent check Point j->i if i->j is already on the convexe hull\r\n                var result = this.checked.find(obj => {\r\n                    return obj.startIdx === j && obj.endIdx ===i;\r\n                })\r\n                if(result) continue;\r\n                let isLineOnHull=true;\r\n                for(let k=0;k<this.points.length;k++){\r\n                    if(i===k || j===k) continue;\r\n                    if(orientationTest(this.points[i], this.points[j], this.points[k])){\r\n                        isLineOnHull=false;\r\n                        break;\r\n                    }\r\n                }\r\n                if(isLineOnHull===true){\r\n                    this.checked.push({startIdx:i, endIdx:j});\r\n                    this.hull.push(this.points[i]);\r\n                    this.hullLines.push({start:this.points[i], end: this.points[j]});\r\n                } else {\r\n\r\n                }\r\n            }\r\n        }\r\n        this.drawFinish();\r\n        this.stop(); \r\n    }\r\n\r\n    //Computes the Algorithm \"slow\" (Every Step is displayed)\r\n    start(){\r\n        let i=0;\r\n        let j=0;\r\n        let k=0;\r\n        let i_ONHOLD=false;\r\n        let j_ONHOLD=false;\r\n        let length=this.points.length;\r\n        let isLineOnHull;\r\n\r\n        let intervallID = setInterval(() => {\r\n            reset();\r\n            if(i===j){\r\n                j++;\r\n            }else{\r\n                var result = this.checked.find(obj => {\r\n                    return obj.startIdx === j && obj.endIdx ===i;\r\n                })\r\n                if(!result){\r\n                    if(!j_ONHOLD) isLineOnHull=true;\r\n                        i_ONHOLD=true;\r\n                        j_ONHOLD=true;\r\n                        drawLine(this.points[i],this.points[j]);\r\n                        if(i!==k && j!==k){\r\n                            drawLine(this.points[i],this.points[k],\"green\");\r\n                            if(orientationTest(this.points[i], this.points[j], this.points[k])){\r\n                                isLineOnHull=false;\r\n                            }\r\n                            k++;\r\n                        } else {\r\n                            k++;\r\n                        }\r\n                        if(k===length){\r\n                            j_ONHOLD=false;\r\n                            k=0;\r\n                        }\r\n                    if(isLineOnHull===true && k===0){\r\n                        this.checked.push({startIdx:i, endIdx:j});\r\n                        this.hull.push(this.points[i]);\r\n                        this.hullLines.push({start:this.points[i], end: this.points[j]});\r\n                        if(!j_ONHOLD)j++;\r\n                    } else {\r\n                        if(!j_ONHOLD)j++;\r\n                    }\r\n                } else {\r\n                    if(!j_ONHOLD)j++;\r\n                }\r\n            }\r\n            if(j===length){\r\n                i_ONHOLD=false;\r\n                j=0;\r\n            }\r\n            if(!i_ONHOLD&&j===0){\r\n                i++;\r\n                j=0;\r\n            }\r\n\r\n            if(i===length)this.stop(intervallID);\r\n            for(let p=0;p<this.hullLines.length;p++){\r\n                drawLine(this.hullLines[p].start,this.hullLines[p].end, \"red\");\r\n            }\r\n            for(let p=0;p<this.points.length;p++){\r\n                this.points[p].draw();\r\n            }\r\n    \r\n            for(let p=0;p<this.hull.length;p++){\r\n                this.hull[p].draw(5,\"red\");\r\n            }\r\n        }, 100);\r\n        this.drawFinish();\r\n    }\r\n\r\n   //Draws the Finished Convexe Hull\r\n    drawFinish(){\r\n        reset();\r\n        for(let i=0;i<this.hullLines.length;i++){\r\n            drawLine(this.hullLines[i].start,this.hullLines[i].end,\"red\");\r\n        }\r\n        for(let i=0;i<this.points.length;i++){\r\n            this.points[i].draw();\r\n        }\r\n\r\n        for(let i=0;i<this.hull.length;i++){\r\n            this.hull[i].draw(5,\"red\");\r\n        }\r\n    }\r\n\r\n    //Stops the Interval and sets success to true (Convexe Hull is Found)\r\n    stop(id){\r\n        clearInterval(id);\r\n        this.sucess=true;\r\n    }\r\n}\r\n","/**\r\n * This file computes the Graham Scan Algorithm to Compute the Convexe Hull\r\n */\r\nimport {drawPolygonLines, reset} from \"../Help/drawMethods\";\r\nimport {orientationTest, initAngleArray} from \"../Help/calculations\";\r\n\r\nexport default class GrahamScan{\r\n    constructor(points){\r\n        this.points=points.sort((a,b) => a.y-b.y);;\r\n        this.success=false;\r\n        this.hull=[];\r\n        this.hull.push(this.points[0]);\r\n    }\r\n\r\n    instantCompute(){  \r\n        // Sort the Array in increasing Order of the Angel they and the point this.points[0] make with the x-axis\r\n        this.points = initAngleArray(this.points[0], this.points);\r\n        this.hull.push(this.points[1]);\r\n        let i=2;\r\n        let n=this.points.length;\r\n        while(i<n){\r\n            let pt_1= this.hull[this.hull.length-1];\r\n            let pt_2= this.hull[this.hull.length-2];\r\n            if(!orientationTest(pt_1,pt_2,this.points[i]) || this.hull.length==2){\r\n                this.hull.push(this.points[i]);\r\n                i++;\r\n            } else {\r\n                this.hull.pop();\r\n            }\r\n        }\r\n        this.drawCurrentState(true);\r\n    }\r\n\r\n    start(){\r\n        // Sort the Array in increasing Order of the Angel they and the point this.points[0] make with the x-axis\r\n        this.points = initAngleArray(this.points[0], this.points);\r\n        this.hull.push(this.points[1]);\r\n        let i=2;\r\n        let n=this.points.length;\r\n        let intervallID = setInterval(() => {\r\n            let pt_1= this.hull[this.hull.length-1];\r\n            let pt_2= this.hull[this.hull.length-2];\r\n            this.drawCurrentState();\r\n            if(!orientationTest(pt_1,pt_2,this.points[i]) || this.hull.length==2){\r\n                this.hull.push(this.points[i]);\r\n                i++;\r\n            } else {\r\n                this.hull.pop();\r\n            }   \r\n            if(i>=n){\r\n                this.stop(intervallID); \r\n                this.drawCurrentState(true);\r\n            } \r\n        }, 300);\r\n    }\r\n\r\n    //Draws the Current State (all Points, current points of the hull, and lines)\r\n    drawCurrentState(finished=false){\r\n        reset();\r\n        if(finished){\r\n            drawPolygonLines(this.hull, \"red\", true);\r\n        } else {\r\n            drawPolygonLines(this.hull, \"red\", false);\r\n        }\r\n\r\n        for(let p=0;p<this.points.length;p++){\r\n            this.points[p].draw();\r\n        }\r\n\r\n        for(let p=0;p<this.hull.length;p++){\r\n            this.hull[p].draw(5,\"red\");\r\n        } \r\n    }\r\n\r\n    //Stops the Interval and sets success to true (Convexe Hull is Found)\r\n    stop(id){\r\n        clearInterval(id);\r\n        this.sucess=true;\r\n    }\r\n}","/**\r\n * This File Handles the Start of the different Algoritms\r\n */\r\n\r\nimport Point from \"./Point/point\";\r\nimport GiftWrappingAlgorithm from \"../Algorithms/gift-wrapping-algorithm\";\r\nimport NaiveAlgorithm from \"../Algorithms/naive\";\r\nimport GrahamScan from \"../Algorithms//graham-scan\";\r\nimport {reset} from \"../Help/drawMethods\";\r\n\r\nexport default class Plane{\r\n    constructor(){\r\n        this.points=[];\r\n        this.algorithm=null;\r\n        this.success=false;\r\n    }\r\n\r\n    //Adds a Point to the variable this.points\r\n    addPoint(x,y){\r\n        this.points.push(new Point(x,y));\r\n        this.draw();\r\n    }\r\n\r\n    //Computes the Naive Algorithm to find the Convexe Hull\r\n    naive(isFinished){\r\n        if(this.points.length<3){\r\n            return\r\n        }\r\n        this.algorithm = new NaiveAlgorithm(this.points);\r\n        if(isFinished){\r\n            this.algorithm.instantCompute();    \r\n        } else {\r\n            this.algorithm.start();\r\n        }\r\n    }\r\n\r\n    //Computes the Gift Wrapping Algorithm to find the Convexe Hull\r\n    giftWrapping(isFinished){\r\n        if(this.points.length<3){\r\n            return\r\n        }\r\n        this.algorithm = new GiftWrappingAlgorithm(this.points);\r\n        if(isFinished){\r\n            this.algorithm.instantCompute();    \r\n        } else {\r\n            this.algorithm.start();\r\n        }\r\n    }\r\n\r\n    //Computes the Graham Scan Algorithm to find the Convexe Hull\r\n    grahamScan(isFinished){\r\n        if(this.points.length<3){\r\n            return\r\n        }\r\n        this.algorithm = new GrahamScan(this.points);\r\n        if(isFinished){\r\n            this.algorithm.instantCompute();    \r\n        } else {\r\n            this.algorithm.start();\r\n        }\r\n    }\r\n\r\n    //Return True if the Convexe hull is found\r\n    isAlgorithmFinished(){\r\n        if(this.algorithm==null) return null;\r\n        return this.algorithm.sucess;\r\n    }\r\n\r\n    //Resets the Canvas\r\n    reset(){\r\n       reset();\r\n    }\r\n\r\n    //Draw all Points\r\n    draw(){\r\n        this.reset();\r\n        for(let i=0;i<this.points.length;i++){\r\n            this.points[i].draw();\r\n        }\r\n    }\r\n}","import \"./conexehull.css\";\r\nimport React from 'react';\r\nimport Plane from \"./Plane/plane\";\r\nimport {Button} from '@material-ui/core';\r\n\r\nconst CANVAS_WIDTH=800;\r\nconst CANVAS_HEIGHT=400;\r\n\r\nconst NONE_ALGO=-1;\r\nconst NAIVE=0;\r\nconst GIFT_WRAPPING=1;\r\nconst GRAHAM_SCAN=2;\r\n\r\nexport default class ConvexeHull extends React.Component{\r\n    intervallID=0\r\n    constructor(props){\r\n        super(props);\r\n        this.state = {\r\n            plane: new Plane(),\r\n            isRunning:false,\r\n            isFinished:false,\r\n            algoMode: NONE_ALGO,\r\n        }\r\n    }\r\n\r\n    componentDidMount(){\r\n        this.state.plane.reset();\r\n    }\r\n\r\n    // Computes the Algorithm \"fast\" (Only the finised State will be displayed)\r\n    fastCompute(){\r\n        this.setState({isFinished:true});\r\n        switch(this.state.algoMode){\r\n            case NAIVE:\r\n                this.state.plane.naive(true);\r\n                break;\r\n            case GIFT_WRAPPING:\r\n                this.state.plane.giftWrapping(true);\r\n                break;\r\n            case GRAHAM_SCAN:\r\n                this.state.plane.grahamScan(true);\r\n                break;\r\n            default:\r\n                this.setState({isRunning:false})\r\n                return;\r\n        }\r\n        \r\n    }\r\n\r\n    //Computes the Algorithms \"slowly\" (every stape will be displayed)\r\n    animation(){\r\n        this.setState({isRunning:true})\r\n        switch(this.state.algoMode){\r\n            case NAIVE:\r\n                this.state.plane.naive(false);\r\n                this.intervallID = setInterval(() => {\r\n                    if(this.state.plane.isAlgorithmFinished()){\r\n                        this.stop(this.intervallID);\r\n                    } \r\n                },50);\r\n                break;\r\n            case GIFT_WRAPPING:\r\n                this.state.plane.giftWrapping(false);\r\n                this.intervallID = setInterval(() => {\r\n                    if(this.state.plane.isAlgorithmFinished()){\r\n                        this.stop(this.intervallID);\r\n                    } \r\n                },50);\r\n                break;\r\n            case GRAHAM_SCAN:\r\n                this.state.plane.grahamScan(false);\r\n                this.intervallID = setInterval(() => {\r\n                    if(this.state.plane.isAlgorithmFinished()){\r\n                        this.stop(this.intervallID);\r\n                    } \r\n                },50);\r\n                break;\r\n            default:\r\n                this.setState({isRunning:false})\r\n                return;\r\n        }\r\n\r\n    }\r\n\r\n    //Resets only the ConvexeHull from the Canvas (Not the points)\r\n    resetHull(){\r\n        this.state.plane.draw();\r\n        this.setState({isFinished:false});\r\n    }\r\n\r\n    //Resets the every thing on the Canvas (Points, lines,...)\r\n    reset(){\r\n        this.setState({isRunning:false, isFinished:false, plane:new Plane()});\r\n        setTimeout(() => {\r\n            this.state.plane.draw();\r\n        },10);      \r\n    }\r\n\r\n    //Stops the Animation of the  Algorithm\r\n    stop(id){\r\n        clearInterval(id);\r\n        this.setState({isRunning:false, isFinished:true});\r\n    }\r\n\r\n    //Stops all Running Intervals\r\n    stopAll(){\r\n        var interval_id = window.setInterval(\"\", 9999); // Get a reference to the last\r\n                                                // interval +1\r\n        for (var i = 1; i < interval_id; i++)\r\n            window.clearInterval(i);\r\n        this.setState({isRunning:false});\r\n        if(!this.state.isFinished) this.state.plane.draw();\r\n    }\r\n\r\n    //Add Random Points in the Canvas\r\n    addRandomPoints(){\r\n        for(let i=0;i< 5;i++){\r\n            let x = Math.random()*CANVAS_WIDTH;\r\n            let y = Math.random()*CANVAS_HEIGHT;\r\n            this.state.plane.addPoint(x,y);\r\n        }\r\n    }\r\n\r\n    //Add on Click Points in the Canvas. And if this.state.isFinished===true then the new ConvexeHUll\r\n    //will be compute immediatly\r\n    addPoint(e){\r\n        var canvas = document.getElementById(\"2d-plane\");\r\n        var pos = this.getMousePos(canvas, e);\r\n        this.state.plane.addPoint(pos.x,pos.y);\r\n        if(this.state.isFinished){\r\n            switch (this.state.algoMode){\r\n                case NAIVE:\r\n                    this.state.plane.naive(true);\r\n                    break;\r\n                case GIFT_WRAPPING:\r\n                    this.state.plane.giftWrapping(true);\r\n                    break;\r\n                case GRAHAM_SCAN:\r\n                    this.state.plane.grahamScan(true);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    //Gets the Mouse position on the Canvas\r\n    getMousePos(canvas, evt) {\r\n        var rect = canvas.getBoundingClientRect();\r\n        return {\r\n        x: evt.clientX - rect.left,\r\n        y: evt.clientY - rect.top\r\n        };\r\n    }\r\n\r\n    //Handler for Switching the Algorithm\r\n    switchAlgoMode(e){\r\n        this.setState({algoMode: parseInt(e.target.value)});\r\n        this.resetHull();\r\n    }\r\n\r\n    render(){\r\n        return(\r\n            <div className=\"convexehull\">\r\n                <h1>Convexe Hull</h1>\r\n                <select className=\"select-css\" onChange={(e,val) => this.switchAlgoMode(e,val)}>\r\n                    <option value=\"-1\">Select Algorithm</option>\r\n                    <option value={NAIVE}>Naive</option>\r\n                    <option value={GIFT_WRAPPING}>Gift Wrapping</option>\r\n                    <option value={GRAHAM_SCAN}>Graham Scan</option>\r\n                </select>\r\n                <Button disabled={this.state.isRunning} variant=\"outlined\" color=\"primary\" onClick={() => this.fastCompute()}>Fast Compute</Button>\r\n                <Button disabled={this.state.isRunning} variant=\"outlined\" color=\"primary\" onClick={() => this.animation()}>Animation</Button>\r\n                <Button disabled={!this.state.isRunning} variant=\"outlined\" color=\"secondary\" onClick={() => this.stopAll()}>Stop</Button>\r\n                <Button disabled={this.state.isRunning} variant=\"outlined\" onClick={() => this.addRandomPoints()}>Random Points</Button>\r\n                <Button disabled={this.state.isRunning} variant=\"outlined\" onClick={()=> this.resetHull()}>Reset Hull</Button>\r\n                <Button disabled={this.state.isRunning} variant=\"outlined\" onClick={()=> this.reset()}>Reset</Button>\r\n        <       h4>{this.state.isRunning? \"Compute...\": \"Ready\"}</h4>\r\n                <div className=\"convexehull__canvas\">\r\n                    <canvas className=\"convexehull_canvas__2dplane\" id=\"2d-plane\" width={CANVAS_WIDTH} height={CANVAS_HEIGHT}\r\n                    onClick={this.state.isRunning ?() => null :(e) => this.addPoint(e)}\r\n                    ></canvas>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}","import './App.css';\nimport ConvexeHull from \"./ConvexeHull/convexehull\";\n\nfunction App() {\n  return (\n    <div className=\"app\">\n      <ConvexeHull></ConvexeHull>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}